// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'link_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LinkType<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hostedVideo,
    required TResult Function() imageLink,
    required TResult Function() link,
    required TResult Function() richVideo,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? hostedVideo,
    TResult? Function()? imageLink,
    TResult? Function()? link,
    TResult? Function()? richVideo,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hostedVideo,
    TResult Function()? imageLink,
    TResult Function()? link,
    TResult Function()? richVideo,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HostedVideo<T> value) hostedVideo,
    required TResult Function(ImageLink<T> value) imageLink,
    required TResult Function(Link<T> value) link,
    required TResult Function(RichVideo<T> value) richVideo,
    required TResult Function(None<T> value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HostedVideo<T> value)? hostedVideo,
    TResult? Function(ImageLink<T> value)? imageLink,
    TResult? Function(Link<T> value)? link,
    TResult? Function(RichVideo<T> value)? richVideo,
    TResult? Function(None<T> value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HostedVideo<T> value)? hostedVideo,
    TResult Function(ImageLink<T> value)? imageLink,
    TResult Function(Link<T> value)? link,
    TResult Function(RichVideo<T> value)? richVideo,
    TResult Function(None<T> value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LinkTypeCopyWith<T, $Res> {
  factory $LinkTypeCopyWith(
          LinkType<T> value, $Res Function(LinkType<T>) then) =
      _$LinkTypeCopyWithImpl<T, $Res, LinkType<T>>;
}

/// @nodoc
class _$LinkTypeCopyWithImpl<T, $Res, $Val extends LinkType<T>>
    implements $LinkTypeCopyWith<T, $Res> {
  _$LinkTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$HostedVideoCopyWith<T, $Res> {
  factory _$$HostedVideoCopyWith(
          _$HostedVideo<T> value, $Res Function(_$HostedVideo<T>) then) =
      __$$HostedVideoCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$HostedVideoCopyWithImpl<T, $Res>
    extends _$LinkTypeCopyWithImpl<T, $Res, _$HostedVideo<T>>
    implements _$$HostedVideoCopyWith<T, $Res> {
  __$$HostedVideoCopyWithImpl(
      _$HostedVideo<T> _value, $Res Function(_$HostedVideo<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HostedVideo<T> implements HostedVideo<T> {
  const _$HostedVideo();

  @override
  String toString() {
    return 'LinkType<$T>.hostedVideo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HostedVideo<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hostedVideo,
    required TResult Function() imageLink,
    required TResult Function() link,
    required TResult Function() richVideo,
    required TResult Function() none,
  }) {
    return hostedVideo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? hostedVideo,
    TResult? Function()? imageLink,
    TResult? Function()? link,
    TResult? Function()? richVideo,
    TResult? Function()? none,
  }) {
    return hostedVideo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hostedVideo,
    TResult Function()? imageLink,
    TResult Function()? link,
    TResult Function()? richVideo,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (hostedVideo != null) {
      return hostedVideo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HostedVideo<T> value) hostedVideo,
    required TResult Function(ImageLink<T> value) imageLink,
    required TResult Function(Link<T> value) link,
    required TResult Function(RichVideo<T> value) richVideo,
    required TResult Function(None<T> value) none,
  }) {
    return hostedVideo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HostedVideo<T> value)? hostedVideo,
    TResult? Function(ImageLink<T> value)? imageLink,
    TResult? Function(Link<T> value)? link,
    TResult? Function(RichVideo<T> value)? richVideo,
    TResult? Function(None<T> value)? none,
  }) {
    return hostedVideo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HostedVideo<T> value)? hostedVideo,
    TResult Function(ImageLink<T> value)? imageLink,
    TResult Function(Link<T> value)? link,
    TResult Function(RichVideo<T> value)? richVideo,
    TResult Function(None<T> value)? none,
    required TResult orElse(),
  }) {
    if (hostedVideo != null) {
      return hostedVideo(this);
    }
    return orElse();
  }
}

abstract class HostedVideo<T> implements LinkType<T> {
  const factory HostedVideo() = _$HostedVideo<T>;
}

/// @nodoc
abstract class _$$ImageLinkCopyWith<T, $Res> {
  factory _$$ImageLinkCopyWith(
          _$ImageLink<T> value, $Res Function(_$ImageLink<T>) then) =
      __$$ImageLinkCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ImageLinkCopyWithImpl<T, $Res>
    extends _$LinkTypeCopyWithImpl<T, $Res, _$ImageLink<T>>
    implements _$$ImageLinkCopyWith<T, $Res> {
  __$$ImageLinkCopyWithImpl(
      _$ImageLink<T> _value, $Res Function(_$ImageLink<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ImageLink<T> implements ImageLink<T> {
  const _$ImageLink();

  @override
  String toString() {
    return 'LinkType<$T>.imageLink()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ImageLink<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hostedVideo,
    required TResult Function() imageLink,
    required TResult Function() link,
    required TResult Function() richVideo,
    required TResult Function() none,
  }) {
    return imageLink();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? hostedVideo,
    TResult? Function()? imageLink,
    TResult? Function()? link,
    TResult? Function()? richVideo,
    TResult? Function()? none,
  }) {
    return imageLink?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hostedVideo,
    TResult Function()? imageLink,
    TResult Function()? link,
    TResult Function()? richVideo,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (imageLink != null) {
      return imageLink();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HostedVideo<T> value) hostedVideo,
    required TResult Function(ImageLink<T> value) imageLink,
    required TResult Function(Link<T> value) link,
    required TResult Function(RichVideo<T> value) richVideo,
    required TResult Function(None<T> value) none,
  }) {
    return imageLink(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HostedVideo<T> value)? hostedVideo,
    TResult? Function(ImageLink<T> value)? imageLink,
    TResult? Function(Link<T> value)? link,
    TResult? Function(RichVideo<T> value)? richVideo,
    TResult? Function(None<T> value)? none,
  }) {
    return imageLink?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HostedVideo<T> value)? hostedVideo,
    TResult Function(ImageLink<T> value)? imageLink,
    TResult Function(Link<T> value)? link,
    TResult Function(RichVideo<T> value)? richVideo,
    TResult Function(None<T> value)? none,
    required TResult orElse(),
  }) {
    if (imageLink != null) {
      return imageLink(this);
    }
    return orElse();
  }
}

abstract class ImageLink<T> implements LinkType<T> {
  const factory ImageLink() = _$ImageLink<T>;
}

/// @nodoc
abstract class _$$LinkCopyWith<T, $Res> {
  factory _$$LinkCopyWith(_$Link<T> value, $Res Function(_$Link<T>) then) =
      __$$LinkCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$LinkCopyWithImpl<T, $Res>
    extends _$LinkTypeCopyWithImpl<T, $Res, _$Link<T>>
    implements _$$LinkCopyWith<T, $Res> {
  __$$LinkCopyWithImpl(_$Link<T> _value, $Res Function(_$Link<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Link<T> implements Link<T> {
  const _$Link();

  @override
  String toString() {
    return 'LinkType<$T>.link()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Link<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hostedVideo,
    required TResult Function() imageLink,
    required TResult Function() link,
    required TResult Function() richVideo,
    required TResult Function() none,
  }) {
    return link();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? hostedVideo,
    TResult? Function()? imageLink,
    TResult? Function()? link,
    TResult? Function()? richVideo,
    TResult? Function()? none,
  }) {
    return link?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hostedVideo,
    TResult Function()? imageLink,
    TResult Function()? link,
    TResult Function()? richVideo,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (link != null) {
      return link();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HostedVideo<T> value) hostedVideo,
    required TResult Function(ImageLink<T> value) imageLink,
    required TResult Function(Link<T> value) link,
    required TResult Function(RichVideo<T> value) richVideo,
    required TResult Function(None<T> value) none,
  }) {
    return link(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HostedVideo<T> value)? hostedVideo,
    TResult? Function(ImageLink<T> value)? imageLink,
    TResult? Function(Link<T> value)? link,
    TResult? Function(RichVideo<T> value)? richVideo,
    TResult? Function(None<T> value)? none,
  }) {
    return link?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HostedVideo<T> value)? hostedVideo,
    TResult Function(ImageLink<T> value)? imageLink,
    TResult Function(Link<T> value)? link,
    TResult Function(RichVideo<T> value)? richVideo,
    TResult Function(None<T> value)? none,
    required TResult orElse(),
  }) {
    if (link != null) {
      return link(this);
    }
    return orElse();
  }
}

abstract class Link<T> implements LinkType<T> {
  const factory Link() = _$Link<T>;
}

/// @nodoc
abstract class _$$RichVideoCopyWith<T, $Res> {
  factory _$$RichVideoCopyWith(
          _$RichVideo<T> value, $Res Function(_$RichVideo<T>) then) =
      __$$RichVideoCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$RichVideoCopyWithImpl<T, $Res>
    extends _$LinkTypeCopyWithImpl<T, $Res, _$RichVideo<T>>
    implements _$$RichVideoCopyWith<T, $Res> {
  __$$RichVideoCopyWithImpl(
      _$RichVideo<T> _value, $Res Function(_$RichVideo<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RichVideo<T> implements RichVideo<T> {
  const _$RichVideo();

  @override
  String toString() {
    return 'LinkType<$T>.richVideo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RichVideo<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hostedVideo,
    required TResult Function() imageLink,
    required TResult Function() link,
    required TResult Function() richVideo,
    required TResult Function() none,
  }) {
    return richVideo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? hostedVideo,
    TResult? Function()? imageLink,
    TResult? Function()? link,
    TResult? Function()? richVideo,
    TResult? Function()? none,
  }) {
    return richVideo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hostedVideo,
    TResult Function()? imageLink,
    TResult Function()? link,
    TResult Function()? richVideo,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (richVideo != null) {
      return richVideo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HostedVideo<T> value) hostedVideo,
    required TResult Function(ImageLink<T> value) imageLink,
    required TResult Function(Link<T> value) link,
    required TResult Function(RichVideo<T> value) richVideo,
    required TResult Function(None<T> value) none,
  }) {
    return richVideo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HostedVideo<T> value)? hostedVideo,
    TResult? Function(ImageLink<T> value)? imageLink,
    TResult? Function(Link<T> value)? link,
    TResult? Function(RichVideo<T> value)? richVideo,
    TResult? Function(None<T> value)? none,
  }) {
    return richVideo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HostedVideo<T> value)? hostedVideo,
    TResult Function(ImageLink<T> value)? imageLink,
    TResult Function(Link<T> value)? link,
    TResult Function(RichVideo<T> value)? richVideo,
    TResult Function(None<T> value)? none,
    required TResult orElse(),
  }) {
    if (richVideo != null) {
      return richVideo(this);
    }
    return orElse();
  }
}

abstract class RichVideo<T> implements LinkType<T> {
  const factory RichVideo() = _$RichVideo<T>;
}

/// @nodoc
abstract class _$$NoneCopyWith<T, $Res> {
  factory _$$NoneCopyWith(_$None<T> value, $Res Function(_$None<T>) then) =
      __$$NoneCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$NoneCopyWithImpl<T, $Res>
    extends _$LinkTypeCopyWithImpl<T, $Res, _$None<T>>
    implements _$$NoneCopyWith<T, $Res> {
  __$$NoneCopyWithImpl(_$None<T> _value, $Res Function(_$None<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$None<T> implements None<T> {
  const _$None();

  @override
  String toString() {
    return 'LinkType<$T>.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$None<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() hostedVideo,
    required TResult Function() imageLink,
    required TResult Function() link,
    required TResult Function() richVideo,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? hostedVideo,
    TResult? Function()? imageLink,
    TResult? Function()? link,
    TResult? Function()? richVideo,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? hostedVideo,
    TResult Function()? imageLink,
    TResult Function()? link,
    TResult Function()? richVideo,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HostedVideo<T> value) hostedVideo,
    required TResult Function(ImageLink<T> value) imageLink,
    required TResult Function(Link<T> value) link,
    required TResult Function(RichVideo<T> value) richVideo,
    required TResult Function(None<T> value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HostedVideo<T> value)? hostedVideo,
    TResult? Function(ImageLink<T> value)? imageLink,
    TResult? Function(Link<T> value)? link,
    TResult? Function(RichVideo<T> value)? richVideo,
    TResult? Function(None<T> value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HostedVideo<T> value)? hostedVideo,
    TResult Function(ImageLink<T> value)? imageLink,
    TResult Function(Link<T> value)? link,
    TResult Function(RichVideo<T> value)? richVideo,
    TResult Function(None<T> value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class None<T> implements LinkType<T> {
  const factory None() = _$None<T>;
}
